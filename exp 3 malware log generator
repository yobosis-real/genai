import torch
import torch.nn as nn
import torch.optim as optim
import random

logs = [
    "process injection detected",
    "suspicious dll loaded",
    "outbound traffic to blacklisted domain",
    "privilege escalation attempt",
    "keylogger activity found"
]

words = list(set(" ".join(logs).split()))
w2i = {w: i for i, w in enumerate(words)}
i2w = {i: w for w, i in w2i.items()}

V = len(words)     # vocab size
Z = 8              # noise size

G = nn.Sequential(
    nn.Linear(Z, V),
    nn.Softmax(dim=1)
)

D = nn.Sequential(
    nn.Linear(V, 1),
    nn.Sigmoid()
)

g_opt = optim.Adam(G.parameters(), lr=0.01)
d_opt = optim.Adam(D.parameters(), lr=0.01)

def one_hot(idx):
    x = torch.zeros(1, V)
    x[0, idx] = 1
    return x

for _ in range(100):
    real_word = one_hot(random.randint(0, V-1))
    noise = torch.randn(1, Z)
    fake_word = G(noise)

    d_opt.zero_grad()
    d_loss = -torch.log(D(real_word)) - torch.log(1 - D(fake_word.detach()))
    d_loss.mean().backward()
    d_opt.step()

    g_opt.zero_grad()
    g_loss = -torch.log(D(fake_word))
    g_loss.mean().backward()
    g_opt.step()

noise = torch.randn(1, Z)
word_index = G(noise).argmax(dim=1).item()
print("Generated word:", i2w[word_index])
